/*
================================================================================
Server-Side Capture-The-Flag Gametype Library
for Medal Of Honor
Version 1.4.2 (05/14/05)

Copyright (c) 2003-2005 Mark Follett
email: mef123@geocities.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
================================================================================
*/


register_gametypes:
	level.mef_gametypes["ctf"] = global/libmef/ctf.scr::init_gametype
	level.mef_gametypes["ftctf"] = global/libmef/ctf.scr::init_gametype
end


init_gametype:
	switch (self.gametype)
	{
		case "ctf":
			self.gametypestring = "Capture-The-Flag"
			break
		
		case "ftctf":
			self.gametypestring = "Freeze-Tag-CTF"
			break
	}
	
	if (level.mef_maptype == "obj")
	{
		self.basegametype = 4
	} else
	{
		self.basegametype = 3
	}

	waitthread global/libmef/gametypes.scr::new_setting "pointlimit"     int  4
	waitthread global/libmef/gametypes.scr::new_setting "suddendeath"    int  5
	waitthread global/libmef/gametypes.scr::new_setting "fsuddendeath"   int  2
	waitthread global/libmef/gametypes.scr::new_setting "returnboth"     bool 0
	waitthread global/libmef/gametypes.scr::new_setting "countdown"      int 15
	waitthread global/libmef/gametypes.scr::new_setting "returnpress"    int 15
	waitthread global/libmef/gametypes.scr::new_setting "capturepress"   int 20
	waitthread global/libmef/gametypes.scr::new_setting "drophold"       int -1
	waitthread global/libmef/gametypes.scr::new_setting "friendlyreturn" int  7
	waitthread global/libmef/gametypes.scr::new_setting "enemyreturn"    int -1
	waitthread global/libmef/gametypes.scr::new_setting "groundreturn"   int 25
	waitthread global/libmef/gametypes.scr::new_setting "dropdelay"      int 20
	waitthread global/libmef/gametypes.scr::new_setting "announce"       options "dropped atbase" "captured dropped atbase abbr"
	waitthread global/libmef/gametypes.scr::new_setting "announcefreq"   int  8

	waitthread global/libmef/util.scr::add_logging_settings

	if (self.gametype == "ctf")
	{
		waitthread global/libmef/gametypes.scr::new_setting "respawn" bool 1
	}
	
	if (self.gametype == "ftctf")
	{
		waitthread global/libmef/ft.scr::add_freezetag_settings
	}

	waitthread global/libmef/gametypes.scr::add_roundbased_settings
	waitthread global/libmef/spectate.scr::add_spectate_settings
	waitthread global/libmef/respawn.scr::add_respawncontrol_settings

	self.settingsthread = global/libmef/ctf.scr::process_settings
	
	thread ctf_begin
end


process_settings:
	if (level.mef_gametype == "ftctf" || (level.mef_gametype == "ctf" && !level.mef_settings["respawn"]))
	{
		level.mef_deepbases = 1
	}
	waitthread global/libmef/spectate.scr::process_settings
end


ctf_begin:
	if (level.ctf_running)
	{
		end
	}

	level.ctf_running = 1
	
	level waittill prespawn
	
	level.ctf_version = "1.4.2"

	waitthread global/libmef/util.scr::read_gametype_settings
	thread global/libmef/respawn.scr::respawncontrol_thread
	
	level.mef_settings["button_fov"] = 60
	level.mef_settings["button_pressdist"] = 96

	if (level.mef_gametype == "ctf")
	{
		if (level.mef_settings["respawn"])
		{
			level.mef_respawnmode = "full"
			local.waverespawn = 0
		} else
		{
			level.mef_respawnmode = "none"
			level.ctf_baserespawnmode = "none"
			local.waverespawn = 1
			level.mef_lockspawns = 1
		}
		local.gtypename = "Capture-The-Flag"
	} else
	{
		level.mef_respawnmode = "ft"
		level.ctf_baserespawnmode = "ft"
		level.mef_freezemode = 1
		local.waverespawn = 1
		level.mef_lockspawns = 1
		local.gtypename = "Freeze-Tag-CTF"
	}

	waitthread global/libmef/respawn.scr::init_respawnmode level.mef_allies level.mef_respawnmode local.waverespawn
	waitthread global/libmef/respawn.scr::init_respawnmode level.mef_axis level.mef_respawnmode local.waverespawn

	level.mef_pchudenabled = 1
	level.mef_pchudx = 10
	level.mef_pchudy = -200

	level.mef_checkwinthread = global/libmef/util.scr::get_winner_score

	level.ctf_logstrings["posted"] = "POST"
	level.ctf_logstrings["saved"] = "SAVE"
	level.ctf_logstrings["returned"] = "RETURN"
	level.ctf_logstrings["picked up"] = "PICKUP"
	level.ctf_logstrings["captured"] = "CAPTURE"
	level.ctf_logstrings["dropped"] = "DROP"

	level.mef_credits[0] = (local.gtypename + " MOD")
	level.mef_credits[1] = ("Version " + level.ctf_version)
	level.mef_credits[2] = "by Mefy"
	level.mef_credits[3] = "planetmedalofhonor.com/"
	level.mef_credits[4] = "mefy"
	level.mef_credits[5] = ""

	if (level.mef_basegametype == 4)
	{
		setcvar "g_obj_axistext1" (local.gtypename + " MOD")
		setcvar "g_obj_axistext2" "by Mefy"
		setcvar "g_obj_axistext3" ""
	} else
	{
		setcvar "g_obj_axistext1" ""
		setcvar "g_obj_axistext2" (local.gtypename + " MOD")
		setcvar "g_obj_axistext3" "by Mefy"
	}

	setcvar "g_obj_alliedtext1" "Capture and hold" 
	setcvar "g_obj_alliedtext3" "your team's base"

	if (level.mef_settings["returnboth"])
	{
		setcvar "g_obj_alliedtext2" "both flags at"
	} else
	{
		setcvar "g_obj_alliedtext2" "the enemy's flag at"
	}

	waitthread global/libmef/mapdesc.scr::setup_map level.mef_mapname

	level.ctf_bases = waitthread global/libmef/bases.scr::read_base_settings level.mef_settings "both"

	level.dmroundlimit = 12 // round time limit in minutes

	thread global/libmef/bases.scr::spawn_bases level.ctf_bases

	level waittill spawn

	waitthread global/libmef/util.scr::waittill_roundstart

	while (!level.mef_basesspawned)
	{
		waitframe
	}

	level.ctf_ground = waitthread new_ground_entity

	waitthread init_flag_base level.ctf_bases["allies"]
	waitthread init_flag_base level.ctf_bases["axis"]

	level.ctf_flags["allies"] = waitthread new_flag level.ctf_bases["allies"].spots["allies"].origin "allies"
	level.ctf_flags["axis"] = waitthread new_flag level.ctf_bases["axis"].spots["axis"].origin "axis"

	waitthread attach_flag_to_entity level.ctf_flags["allies"] level.ctf_bases["allies"]
	waitthread attach_flag_to_entity level.ctf_flags["axis"] level.ctf_bases["axis"]
	waitframe

	waitthread global/libmef/util.scr::begin_round_based_game NIL global/libmef/ctf.scr::turn_off_flags

	waitthread global/libmef/hud.scr::register_hud_item 4 global/libmef/ctf.scr::setup_hud_display global/libmef/ctf.scr::update_hud_display
	thread check_flag_position_change

	if (level.mef_settings["announcefreq"] > 0)
	{
		thread auto_position_announce level.mef_settings["announcefreq"]
	}
	
	if (level.mef_gametype == "ftctf" || !level.mef_settings["respawn"])
	{
		thread respawnmode_thread
		thread flagcheck_thread
	}
end


flagcheck_thread:
	local.state = "nonecapped"

	while (!level.mef_gameover && !level.mef_fsuddendeath)
	{
		local.alhome = 0
		local.axhome = 0

		if (level.ctf_flags["allies"].carrier == level.ctf_bases["allies"])
		{
			local.alhome = 1
		}
		
		if (level.ctf_flags["axis"].carrier == level.ctf_bases["axis"])
		{
			local.axhome = 1
		}
		
		if (!local.alhome && !local.axhome)
		{
			local.newstate = "bothcapped"
		} else if (local.alhome && local.axhome)
		{
			local.newstate = "nonecapped"
		} else
		{
			local.newstate = "onecapped"
		}
		
		if (local.newstate != local.state)
		{
			if (local.newstate == "onecapped" || local.newstate == "bothcapped")
			{
				local.secs = 4
				level.ctf_respawnmode = "full"
				level.ctf_respawntime = level.time + local.secs
				if (level.mef_respawnmode != "full")
				{
					iprintlnbold_noloc ("Respawning enabled in " + local.secs + " seconds.")
				}
			} else
			{
				local.secs = 10
				level.ctf_respawnmode = level.ctf_baserespawnmode
				level.ctf_respawntime = level.time + local.secs

				if (level.mef_respawnmode == "full")
				{
					if (level.ctf_respawnmode == "ft")
					{
						iprintlnbold_noloc ("Warning: Freeze Tag respawning in " + local.secs + " seconds.")
					} else
					{
						iprintlnbold_noloc ("Warning: Respawning disabled in " + local.secs + " seconds.")
					}
				}
			}
			
			local.state = local.newstate
		}
		
		waitframe
	}
end


respawnmode_thread:
	level.ctf_respawnmode = level.mef_respawnmode

	while (!level.mef_gameover && !level.mef_fsuddendeath)
	{
		if (level.ctf_respawntime != NIL && level.time >= level.ctf_respawntime)
		{
			if (level.ctf_respawnmode != level.mef_respawnmode)
			{
				level.mef_respawnmode = level.ctf_respawnmode
				level.mef_allies.nextrespawnmode = level.mef_respawnmode
				level.mef_axis.nextrespawnmode = level.mef_respawnmode
				
				if (level.mef_respawnmode == "full")
				{
					iprintlnbold_noloc "Full respawning enabled."
				} else
				{
					if (level.mef_respawnmode == "ft")
					{
						iprintlnbold_noloc "Freeze Tag respawning enabled."
					} else
					{
						iprintlnbold_noloc "Respawning disabled."
					}
				}
			}
			
			level.ctf_respawntime = NIL
		}
		
		waitframe
	}
end


turn_off_flags:
	level.ctf_bases["allies"].button.trigger nottriggerable
	level.ctf_bases["axis"].button.trigger nottriggerable
	waitthread disable_flag_pickup level.ctf_flags["axis"]
	waitthread disable_flag_pickup level.ctf_flags["allies"]
end


new_flag local.origin local.team:
	local.ent = spawn script_origin
	local.ent angles ( 0 0 0 )
	local.ent.origin = local.origin
	local.ent.team = local.team
	local.ent.beamstart = ( 0 0 10 )
	local.ent.beamend = ( 0 0 200 )

	local.ent.beam = spawn func_beam
	local.ent.beam minoffset 0.0
	local.ent.beam maxoffset 0.0
	local.ent.beam alpha 1.0
	local.ent.beam color ( 1.0 1.0 1.0 )
	local.ent.beam scale 20.0
	local.ent.beam tileshader ("textures/hud/" + local.team + "_headicon")
	local.ent.beam numsegments 1
	local.ent.beam life 0
	local.ent.beam damage $player[1] 0
	local.ent.beam activate

	local.ent.walktrigger = waitthread new_flag_walk_trigger local.ent local.ent.team
	local.ent.usetrigger = waitthread new_flag_use_trigger local.ent local.ent.team
	waitthread disable_flag_pickup local.ent

	thread flag_beam_thread local.ent
	thread flag_main_thread local.ent
	waitframe
end local.ent


new_flag_walk_trigger local.flag local.team:
	local.ent = spawn trigger_multiple
	local.ent bind local.flag
	local.ent.origin = (local.flag.origin + ( 0 0 100 ))
	local.ent setsize ( -15 -15 -100 ) ( 15 15 100 )
	local.ent.flag = local.flag
	local.ent setthread flag_picked_up
	local.ent.checkvision = 0
end local.ent


new_flag_use_trigger local.flag local.team:
	local.ent = spawn trigger_use
	local.ent bind local.flag
	local.ent.origin = (local.flag.origin + ( 0 0 100 ))
	local.ent setsize ( -30 -30 -130 ) ( 30 30 130 )
	local.ent.flag = local.flag
	local.ent setthread flag_picked_up
	local.ent.checkvision = 1
end local.ent


enable_flag_pickup local.flag:
	local.flag.walktrigger triggerable
	local.flag.usetrigger triggerable
end


disable_flag_pickup local.flag:
	local.flag.walktrigger nottriggerable
	local.flag.usetrigger nottriggerable
end


flag_picked_up:
	local.player = parm.other

	if ((local.player.dmteam == self.flag.grabteam || self.flag.grabteam == "both") && self.flag.carrier != local.player && !local.player.mef_spectator)
	{
		if (!self.checkvision || (self cansee local.player 360 120))
		{
			waitthread player_got_flag self.flag local.player
		}
	}
end


attach_flag_to_entity local.flag local.entity local.team local.event local.player:
	while (!local.flag.candetach)
	{
		waitframe
	}

	if (local.entity != NULL)
	{
		local.flag.candetach = 0
		local.flag.signal delete
		local.flag.signal = local CreateListener

		if (local.flag.carrier != NULL)
		{
			local.flag.carrier.ctf_flags[local.flag.team] = NIL
		}
		local.flag.carrier = local.entity
		local.flag.carrier.ctf_flags[local.flag.team] = local.flag
		local.flag.entteam = local.team
		local.flag.event = local.event
		local.flag.evtplayer = local.player
	}
end


flag_main_thread local.flag:
	local.flag.carrier = level.ctf_ground
	local.flag.signal = local CreateListener

	while (1)
	{
		if (local.flag.carrier.classname == "Player")
		{
			waitthread attach_flag_to_player local.flag local.flag.carrier
		} else if (local.flag.carrier.ctf_attachthread != NIL)
		{
			waitthread local.flag.carrier.ctf_attachthread local.flag local.flag.carrier
		}

		if (local.flag.event)
		{
			waitthread announce_flag_position local.flag local.flag.entteam local.flag.event local.flag.evtplayer
		}

		waitthread update_flag_position_text local.flag

		local.detachthread = local.flag.carrier.ctf_detachthread
		local.oldcarrier = local.flag.carrier

		local.signal = local.flag.signal
		local.flag.candetach = 1
		while (local.signal != NULL)
		{
			waitframe
		}
		
		if (local.detachthread != NIL)
		{
			waitthread local.detachthread local.flag local.oldcarrier
		}
	}
end


flag_beam_thread local.flag:
	while (local.flag != NULL)
	{
		local.flag.beam.origin = (local.flag.origin + local.flag.beamstart)
		local.flag.beam endpoint (local.flag.origin + local.flag.beamend)
		waitframe
	}
end


init_flag_base local.base:
	if (local.base.team == "allies")
	{
		local.color = ( 0.0 0.0 1.0 )
	} else
	{
		local.color = ( 1.0 0.0 0.0 )
	}

	local.base.button = waitthread new_button local.base.buttonorg local.base.buttonang local.color local.base

	local.base.spots["allies"] = waitthread new_flag_spot local.base.alflagorg local.base "allies"
	local.base.spots["axis"] = waitthread new_flag_spot local.base.axflagorg local.base "axis"
	
	if (level.mef_settings["returnpress"] >= 0)
	{
		local.base.spots["allies"] nottriggerable
		local.base.spots["axis"] nottriggerable
	}

	local.base.ctf_attachthread = attach_flag_to_base
	local.base.ctf_detachthread = detach_flag_from_ground
end local.base


new_flag_spot local.origin local.base local.team:
	local.ent = spawn trigger_multiple
	local.ent.origin = local.origin
	local.ent setsize ( -30 -30 -30 ) ( 30 30 30 )
	local.ent.base = local.base
	local.ent.team = local.team
	local.ent.dropteam = local.base.team
	local.ent setthread flag_hit_spot
end local.ent


flag_hit_spot:
	local.player = parm.other
	local.flag = local.player.ctf_flags[self.team]

	if (local.flag != NIL && local.player.dmteam == self.dropteam)
	{
		if (local.player.dmteam == local.flag.team)
		{
			local.event = "returned"
		} else
		{
			local.event = "posted"
		}
		
		waitthread attach_flag_to_entity local.flag self.base self.base.team local.event local.player
	}
end


attach_flag_to_base local.flag local.flagbase:
	local.flag jumpto local.flagbase.spots[local.flag.team].origin

	if (level.mef_settings["capturepress"] < 0)
	{
		local.flag.grabteam = waitthread get_other_team local.flagbase.team
		waitthread enable_flag_pickup_delay local.flag local.ground
	}

	if ((waitthread check_flags_at_base local.flagbase) && !local.flagbase.countdown)
	{
		thread flag_capture_countdown local.flagbase
	}
end


check_flags_at_base local.flagbase:
	if (level.mef_settings["returnboth"])
	{
		if (local.flagbase.ctf_flags["allies"] != NIL && local.flagbase.ctf_flags["axis"] != NIL)
		{
			end 1
		}
	} else 
	{
		if (local.flagbase.ctf_flags[(waitthread get_other_team local.flagbase.team)])
		{
			end 1
		}
	}
end 0


flag_capture_countdown local.flagbase:
	local.flagbase.countdown = 1
	level.mef_scoring[local.flagbase.team] = 1

	local.flagbase.button playsound plantbomb
	local.flagbase.button loopsound bombtick
	
	local.endtime = level.time + level.mef_settings["countdown"]

	while (level.time < local.endtime || local.flagbase.button.pressed == 1)
	{
		wait .1
		if (!(waitthread check_flags_at_base local.flagbase))
		{
			local.flagbase.button stoploopsound
			level.mef_scoring[local.flagbase.team] = NIL
			local.flagbase.countdown = 0
			end
		}
		if (level.time == (local.endtime - 10))
		{
			local.flagbase.button stoploopsound
			local.flagbase.button loopsound final_countdown
		}
 	}

 	local.flagbase.button stoploopsound

	waitthread global/libmef/util.scr::team_scored local.flagbase.team

	if (!level.mef_gameover)
	{
		level.mef_allies.respawnplayers = 1
		level.mef_axis.respawnplayers = 1
	}
	
	local.otherteam = waitthread get_other_team local.flagbase.team
	waitthread attach_flag_to_entity local.flagbase.ctf_flags[local.otherteam] level.ctf_bases[local.otherteam]

	local.flagbase.countdown = 0
end


new_button local.origin local.angles local.color local.base:
	local.ent = spawn script_model
	local.ent model "lights/ceilinglamp1.tik"
	local.ent.origin = local.origin
	local.ent.startpos = local.origin
	local.ent.angles = local.angles
	local.ent notsolid
	local.ent dmg 0
	local.ent scale 0.75
	local.ent.base = local.base

	if (local.base.buttonpressed_sound != NIL)
	{
		local.ent.pressed_sound = local.base.buttonpressed_sound
	} else
	{
		local.ent.pressed_sound = "radiobomb"
	}

	local.ent.pressing_sound = "med_canteen"

	local.ent light local.color[0] local.color[1] local.color[2] 8
	local.ent lightOff
	
	local.ent.trigger = spawn trigger_use
	local.ent.trigger.origin = local.origin
	local.ent.trigger setsize ( -40 -40 -40 ) ( 40 40 40 )
	
	local.ent.pressed = 0
	local.ent thread button_waittill_pressed
end local.ent


button_press local.button:
	local.button.pressed = 1
	local.button lightOn
	local.button playsound self.pressing_sound
	local.button moveTo (local.button.origin + ((angles_toup local.button.angles) * 1.75))
	local.button waitmove
end


button_release local.button:
	local.button moveTo local.button.startpos
	local.button waitmove
	local.button lightOff
	local.button.pressed = 0
end


button_waittill_pressed:
	while (self != NULL)
	{
		self.trigger waittill trigger

		local.player = parm.other
	        if (self != NULL && (waitthread player_can_press self local.player))
	        {
	        	local.player.mef_pressingbutton = 1
	        	
			if (local.player.dmteam == self.base.team)
			{
				if (level.mef_settings["returnpress"] >= 0)
				{
					local.presstime = level.mef_settings["returnpress"]
				} else
				{
					local.presstime = 0
				}
			} else
			{
				if (level.mef_settings["capturepress"] >= 0)
				{
					local.presstime = level.mef_settings["capturepress"]
				} else
				{
					local.presstime = 0
				}
			}
			
			local.counter = 0
			while (local.player != NULL && (Isalive local.player) && (waitthread player_can_press self local.player) && (local.player.useheld == 1))
			{
				if (local.counter >= local.presstime)
				{
					self.base playsound self.pressed_sound
					waitthread button_pressed_event self local.player
					goto complete
				}
				
				if (local.counter == 0)
				{
					local.player stopwatch (local.presstime * .1)
					waitthread button_press self
				}

				wait .1
				local.counter++
			}

complete:
			if (local.counter > 0)
			{
				if (local.player != NULL)
				{
					local.player stopwatch 0
				}
				waitthread button_release self
			}
			
			if (local.player != NULL)
			{
				local.player.mef_pressingbutton = 0
			}
		}
	}
end


player_can_press local.button local.player:
	if (!local.player.mef_spectator)
	{
		if (!(waitthread global/libmef/util.scr::player_can_see local.player local.button level.mef_settings["button_pressdist"]))
		{
			end 0
		}

		if (local.player.dmteam == local.button.base.team)
		{
			// press a button to return a flag
			if (local.player.ctf_flags.size > 0)
			{
				end 1
			}
		} else
		{
			// press a button to capture a flag
			if (local.button.base.ctf_flags.size > 0)
			{
				end 1
			}
		}
	}
end 0


button_pressed_event local.button local.player:
	local.flagbase = self.base

	if (local.player.dmteam == local.flagbase.team)
	{
		// press a button to return a flag
		if (local.player.ctf_flags["allies"] != NIL)
		{
			if (local.player.dmteam == "allies")
			{
				local.event = "returned"
			} else
			{
				local.event = "posted"
			}
			
			waitthread attach_flag_to_entity local.player.ctf_flags["allies"] local.flagbase local.flagbase.team local.event local.player
		}
		
		if (local.player.ctf_flags["axis"] != NIL)
		{
			if (local.player.dmteam == "axis")
			{
				local.event = "returned"
			} else
			{
				local.event = "posted"
			}

			waitthread attach_flag_to_entity local.player.ctf_flags["axis"] local.flagbase local.flagbase.team local.event local.player
		}
	} else
	{
		// press a button to capture a flag
		if (local.flagbase.ctf_flags["allies"] != NIL)
		{
			waitthread player_got_flag local.flagbase.ctf_flags["allies"] local.player
		}

		if (local.flagbase.ctf_flags["axis"] != NIL)
		{
			waitthread player_got_flag local.flagbase.ctf_flags["axis"] local.player
		}
	}
end


attach_flag_to_player local.flag local.player:
	local.flag stop

	if (local.player.ctf_detachthread == NIL)
	{
		local.player.ctf_detachthread = detach_flag_from_player
	}

	waitthread set_flag_positions local.player

	local.flag.beamstart = ( 0 0 15 )
	local.flag.beamend = ( 0 0 110 )
	thread flag_carrier_thread local.flag local.player

	if (level.mef_settings["drophold"] >= 0)
	{
		thread flag_check_drop local.flag local.player
	}
	
	thread msg_player local.player ("You have captured the " + level.mef_team[local.flag.team].desc + " flag!")
	
	if ((local.flag.team == local.player.dmteam) && (level.mef_settings["friendlyreturn"] > 0))
	{
		thread check_flag_return local.flag local.player level.mef_settings["friendlyreturn"] "returned"
	} else if ((local.flag.team != local.player.dmteam) && (level.mef_settings["enemyreturn"] > 0))
	{
		thread check_flag_return local.flag local.player level.mef_settings["enemyreturn"] "atbase"
	}
end


msg_player local.player local.msg:
	local.team = local.player.dmteam
	
	waitframe

	if (local.player != NULL && local.player.dmteam == local.team)
	{
		local.player iprint local.msg
	}
end


detach_flag_from_player local.flag local.player:
	local.flag stop
	if (local.player != NULL)
	{
		waitthread set_flag_positions local.player
		local.player.ctf_dropflag = NIL
	}

	local.flag.beamstart = ( 0 0 10 )
	local.flag.beamend = ( 0 0 200 )
end


set_flag_positions local.player:
	if (local.player.ctf_flags.size == 2)
	{
		local.player.ctf_flags["allies"].playeroffset = ( -10 0 80 )
		local.player.ctf_flags["axis"].playeroffset = ( 10 0 80 )
	} else if (local.player.ctf_flags["allies"] != NIL)
	{
		local.player.ctf_flags["allies"].playeroffset = ( 0 0 80 )
	} else if (local.player.ctf_flags["axis"] != NIL)
	{
		local.player.ctf_flags["axis"].playeroffset = ( 0 0 80 )
	}
end


player_got_flag local.flag local.player:
	if (local.flag.carrier != level.ctf_ground)
	{
		if (local.player.dmteam == local.flag.team)
		{
			local.event = "saved"
		} else
		{
			local.event = "captured"
		}
	} else
	{
		local.event = "picked up"
	}

	if ((local.flag.team == local.player.dmteam) && (level.mef_settings["friendlyreturn"] == 0))
	{
		if (local.event != "saved")
		{
			local.event = "returned"
		}
		waitthread attach_flag_to_entity local.flag level.ctf_bases[local.flag.team] local.flag.team local.event local.player		
	} else
	{
		waitthread attach_flag_to_entity local.flag local.player local.player.dmteam local.event local.player
	}
end


player_dropped_flag local.flag local.player local.team local.lastpos:
	if ((local.flag.team != local.team) && (level.mef_settings["groundreturn"] == 0))
	{
		waitthread attach_flag_to_entity local.flag level.ctf_bases[local.flag.team] local.flag.team "atbase"		
	} else
	{
		local.flag.lastpos = local.lastpos
		waitthread attach_flag_to_entity local.flag level.ctf_ground local.team "dropped" local.player
	}
end


flag_carrier_thread local.flag local.player:
	local.team = local.player.dmteam
	local.lastpos = local.flag.origin
	local.signal = local.flag.signal

	while (local.signal != NULL)
	{
		if (local.player == NULL || local.player.dmteam != local.team || !IsAlive(local.player) || local.player.ctf_dropflag)
		{
			waitthread player_dropped_flag local.flag local.player local.team local.lastpos
			end
		} else
		{
			if ((local.player getposition) == "crouching")
			{
				local.lastpos = (local.flag.origin - ( 0 0 40 ))
			} else
			{
				local.lastpos = local.flag.origin
			}
		}

		local.flag.origin = local.player.origin + ((angles_toleft local.player.angles) * local.flag.playeroffset[0]) + ( ( 0 0 1 ) * local.flag.playeroffset[2])
		waitframe
	}
end


flag_check_drop local.flag local.player:
	local.stopwatchtime = 4
	local.signal = local.flag.signal
	
	while (local.player != NULL && local.signal != NULL && local.player.useheld)
	{
		waitframe
	}

	local.counter = -1
	
	while (local.player != NULL && local.signal != NULL)
	{
		if ((local.counter == 0 || local.player.useheld) && !local.player.mef_pressingbutton)
		{
			if (local.counter == -1)
			{
				// wait a frame to allow a button-press to supercede a drop
				waitframe
				local.counter++
			} else
			{
				if (local.counter == local.stopwatchtime)
				{
					local.player stopwatch ((level.mef_settings["drophold"] - local.stopwatchtime) * 0.1)
					local.stopwatch = 1
				}

				local.counter++
				if (local.counter >= level.mef_settings["drophold"])
				{
					local.player.ctf_dropflag = 1
					end
				}
			
				wait .1
			}
		} else
		{
			if (local.stopwatch)
			{
				local.player stopwatch 0
				local.stopwatch = 0
			}
			
			local.counter = -1
			waitframe
		}
	}
	
	if (local.stopwatch && local.player != NULL)
	{
		local.player stopwatch 0
	}
end


new_ground_entity:
	local.ent = spawn Listener
	local.ent.ctf_attachthread = attach_flag_to_ground
	local.ent.ctf_detachthread = detach_flag_from_ground
end local.ent


attach_flag_to_ground local.flag local.ground:
	if (local.flag.lastpos != NIL)
	{
		local.flag jumpto local.flag.lastpos
		local.flag.lastpos = NIL
	}

	local.flag moveTo (trace local.flag.origin (local.flag.origin + ( 0 0 -10000 )) 1 ( -5 -5 0 ) ( 5 5 0 ))
	local.flag move

	local.flag.grabteam = "both"
	waitthread enable_flag_pickup_delay local.flag local.ground

	if (level.mef_settings["groundreturn"] > 0)
	{
		thread check_flag_return local.flag local.ground level.mef_settings["groundreturn"] "atbase"
	}
end


detach_flag_from_ground local.flag local.ground:
	local.flag stop
	local.flag.beam alpha 1.0
	waitthread disable_flag_pickup local.flag
end


enable_flag_pickup_delay local.flag local.carrier:
	if (level.mef_settings["dropdelay"] > 0)
	{
		thread reset_flag local.flag local.carrier level.mef_settings["dropdelay"]
	} else
	{
		waitthread enable_flag_pickup local.flag
	}
end


reset_flag local.flag local.carrier local.delay:
	local.counter = 0
	local.flag.beam alpha 0.5
	local.signal = local.flag.signal
	
	while (local.signal != NULL)
	{
		local.counter++
		if (local.counter >= local.delay)
		{
			local.flag.beam alpha 1.0
			waitthread enable_flag_pickup local.flag
			end
		}
		wait 0.1
	}
end


check_flag_return local.flag local.carrier local.delay local.event:
	local.counter = 0
	local.signal = local.flag.signal
	
	while (local.signal != NULL)
	{
		local.counter++
		if (local.counter >= local.delay)
		{
			waitthread attach_flag_to_entity local.flag level.ctf_bases[local.flag.team] local.flag.team local.event local.carrier
			end
		}
		wait 1
	}
end


get_other_team local.team:
	if (local.team == "allies")
	{
		end "axis"
	} else
	{
		end "allies"
	}
end


setup_hud_display:
	local.coordx = 10
	local.coordy = -140
	local.ystep = 25

	huddraw_align  self.idx left bottom
	huddraw_font   self.idx facfont-20
	huddraw_rect   self.idx (local.coordx + 30) local.coordy 100 100
	huddraw_color  self.idx 1.0 1.0 1.0
	huddraw_alpha  self.idx 1.0

	huddraw_align  (self.idx + 1) left bottom
	huddraw_font   (self.idx + 1) facfont-20
	huddraw_rect   (self.idx + 1) (local.coordx + 30) (local.coordy + local.ystep) 100 100
	huddraw_color  (self.idx + 1) 1.0 1.0 1.0
	huddraw_alpha  (self.idx + 1) 1.0

	huddraw_shader (self.idx + 2) ("textures/hud/allies")
	huddraw_align (self.idx + 2) left bottom
	huddraw_rect  (self.idx + 2) local.coordx (local.coordy - 5) 25 25
	huddraw_color (self.idx + 2) 1.0 1.0 1.0
	huddraw_alpha (self.idx + 2) 1.0

	huddraw_shader (self.idx + 3) ("textures/hud/axis")
	huddraw_align (self.idx + 3) left bottom
	huddraw_rect  (self.idx + 3) local.coordx (local.coordy + local.ystep - 5) 25 25
	huddraw_color (self.idx + 3) 1.0 1.0 1.0
	huddraw_alpha (self.idx + 3) 1.0
end


update_hud_display:
	local.alliescolor = level.ctf_flagposcol["allies"]
	local.axiscolor = level.ctf_flagposcol["axis"]
	
	huddraw_color self.idx local.alliescolor[0] local.alliescolor[1] local.alliescolor[2]
	huddraw_string self.idx level.ctf_flagpos["allies"]
	huddraw_color (self.idx + 1) local.axiscolor[0] local.axiscolor[1] local.axiscolor[2]
	huddraw_string (self.idx + 1) level.ctf_flagpos["axis"]
end


announce_flag_position local.flag local.team local.action local.player:
	switch (local.action)
	{
		case "posted":
		case "saved":
		case "returned":
		case "picked up":
		case "captured":
		case "dropped":
			if (local.team == "allies")
			{
				local.str = "Allied player "
			} else
			{
				local.str = "Axis player "
			}

			local.name = waitthread global/libmef/util.scr::get_player_name local.player
			if (local.name != NIL)
			{
				local.str += ("(" + local.name + ") ")
				
				if (level.mef_settings["logevents"])
				{
					println ("MEF " + level.ctf_logstrings[local.action] + " " + local.flag.team + " " + (waitthread global/libmef/util.scr::escape_string local.name " " "&"))
				}
			}

			local.str += (local.action + " the " + level.mef_team[local.flag.team].desc + " flag!")
			break
			
		case "atbase":
			local.str = "The " + level.mef_team[local.flag.team].desc + " flag is at the " + level.mef_team[local.team].desc + " base!"
			break
	}
	
	if (local.flag.carrier == level.ctf_ground)
	{
		local.type = "dropped"
	} else if (local.flag.carrier.classname == "Player")
	{
		local.type = "captured"
	} else
	{
		local.type = "atbase"
	}
	
	if (level.mef_settings[("announce_" + local.type)])
	{
		local.str += (waitthread get_flag_full_desc local.flag)
	}
	
	iprintlnbold_noloc local.str
end


get_flag_position_text local.flag local.fulldesc:
	if (local.fulldesc == NIL)
	{
		local.fulldesc = (!level.mef_settings["announce_abbr"])
	}
	

	if (local.fulldesc)
	{
		local.desc = waitthread global/libmef/mapdesc.scr::get_player_position local.flag.origin
	} else
	{
		local.desc = waitthread global/libmef/mapdesc.scr::get_player_position_abbr local.flag.origin
	}
end local.desc


get_flag_full_desc local.flag:
	local.desc = ""
	
	if (local.flag.carrier != level.ctf_ground && local.flag.carrier.classname != "Player")
	{
		// if its attached to the base, then get the base's description
		local.desc = local.flag.carrier.desc
	}

	if (local.desc == "")
	{
		local.desc = waitthread get_flag_position_text local.flag 1
	}

	if (local.desc != "")
	{
		local.desc = " [" + local.desc + "]"
	}
end local.desc


update_flag_position_text local.flag:
	local.desc = waitthread get_flag_position_text local.flag
	
	if (local.flag.carrier == level.ctf_ground)
	{
		local.team = "none"
		local.brackets = "--"

		if (local.desc == "" || !level.mef_settings["announce_dropped"])
		{
			local.desc = "Ground"
		}
	} else if (local.flag.carrier.classname == "Player")
	{
		local.team = local.flag.carrier.dmteam
		local.brackets = "**"

		if (local.desc == "" || !level.mef_settings["announce_captured"])
		{
			if (local.team == "allies")
			{
				local.desc = "Allied Player"
			} else
			{
				local.desc = "Axis Player"
			}
		}
	} else
	{
		local.team = local.flag.carrier.team
		local.brackets = "[]"
		
		if (local.flag.carrier.desc != "")
		{
			local.desc = local.flag.carrier.desc
		}
		
		if (local.desc == "" || !level.mef_settings["announce_atbase"])
		{
			if (local.team == "allies")
			{
				local.desc = "Allied Base"
			} else
			{
				local.desc = "Axis Base"
			}
		}
	}
	
	if (local.desc != "")
	{
		local.desc = local.brackets[0] + local.desc + local.brackets[1]
	}	

	switch (local.team)
	{
		case "allies":
			local.color = ( 0.5 0.5 1.0 )
			break
			
		case "axis":
			local.color = ( 1.0 0.5 0.5 )
			break
		
		default:
			local.color = ( 1.0 1.0 1.0 )
			break
	}
	
	level.ctf_flagpos[local.flag.team] = local.desc
	level.ctf_flagposcol[local.flag.team] = local.color
end


check_flag_position_change:
	while (1)
	{
		if (level.ctf_flagpos["allies"] != local.alliesflagpos || level.ctf_flagposcol["allies"] != local.alliesflagposcol)
		{
			local.alliesflagpos = level.ctf_flagpos["allies"]
			local.alliesflagposcol = level.ctf_flagposcol["allies"]
			level.mef_updatehud = 1
		}
		
		if (level.ctf_flagpos["axis"] != local.axisflagpos || level.ctf_flagposcol["axis"] != local.axisflagposcol)
		{
			local.axisflagpos = level.ctf_flagpos["axis"]
			local.axisflagposcol = level.ctf_flagposcol["axis"]
			level.mef_updatehud = 1
		}

		waitframe
	}
end


auto_position_announce local.freq:
	while (1)
	{
		waitthread update_flag_position_text level.ctf_flags["allies"]
		waitthread update_flag_position_text level.ctf_flags["axis"]
		
		if (local.freq > 0)
		{
			wait local.freq
		} else
		{
			waitframe
		}
	}
end
