/*
================================================================================
Respawning Control Library
for Medal Of Honor
Version 1.2.1 (05/14/05)

Copyright (c) 2004-2005 Mark Follett
email: mef123@geocities.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
================================================================================
*/


respawncontrol_thread:
	thread global/libmef/spectate.scr::monitor_player_state

	level.mef_allowjointime = int(getcvar "g_allowjointime")

	if (level.mef_newmap && level.mef_allowjointime < 30)
	{
		level.mef_allowjointime = 30
	}

	level.dmrespawning = 1

	if (level.mef_basegametype == 5)
	{
		setcvar "sv_team_spawn_interval" "0"
	}

	level.mef_pstatecallbacks.joined_server = global/libmef/respawn.scr::player_joined_server
	level.mef_pstatecallbacks.left_server = global/libmef/respawn.scr::player_left_server
	level.mef_pstatecallbacks.joined_team = global/libmef/respawn.scr::player_joined_team
	level.mef_pstatecallbacks.left_team = global/libmef/respawn.scr::player_left_team
	level.mef_pstatecallbacks.entered_game = global/libmef/respawn.scr::player_entered_game
	level.mef_pstatecallbacks.spawned = global/libmef/respawn.scr::player_spawned
	level.mef_pstatecallbacks.died = global/libmef/respawn.scr::player_died
	level.mef_pstatecallbacks.revived = global/libmef/respawn.scr::player_revived
	level.mef_pstatecallbacks.update_round = global/libmef/respawn.scr::update_round_state

	level waittill spawn
	
	level.dmrespawning = 1

	waitthread global/libmef/util.scr::waittill_roundstart

	if (level.mef_freezemode)
	{
		waitthread global/libmef/ft.scr::init_ft_respawnmode
	}

	local.delay = level.mef_settings["mef_team_spawn_interval"]
	if (local.delay == NIL || local.delay <= 0)
	{
		local.delay = 0
	}
	
	level.mef_allies.respawndelay = local.delay
	level.mef_axis.respawndelay = local.delay

	level.mef_waverespawndelay = 15

	waitthread start_round

	wait 1.0
	
	level.dmrespawning = 1
end


add_respawncontrol_settings:
	waitthread global/libmef/gametypes.scr::new_setting "mef_team_spawn_interval" int 0
end


update_round_state:
	waitthread update_player_count
		
	waitthread check_round_state
		
	if (level.mef_nuketeam != NIL)
	{
		waitthread nuke_team level.mef_nuketeam
		level.mef_nuketeam = NIL
	}
	
	waitthread check_team_state level.mef_allies
	waitthread check_team_state level.mef_axis
	waitthread check_wave_killed
		
	if (!level.mef_gameover)
	{
		if (level.mef_checkwinthread != NIL)
		{
			local.winner = waitthread level.mef_checkwinthread
		}
	
		if (local.winner != NIL)
		{
			if (level.mef_autonuke)
			{
				level.mef_nuketeam = waitthread global/libmef/util.scr::get_other_team local.winner
			}
		
			if (!level.mef_devmode)
			{
				waitthread global/libmef/util.scr::do_teamwin local.winner
			} else if (level.mef_elapsedtime > 10)
			{
				iprintln ("WINNER IS " + local.winner)
				level.mef_gameover = 1
			}
		}
	}

	if (level.mef_allies.spawnfrozenbodies)
	{
		waitthread global/libmef/ft.scr::create_frozen_bodies "allies"
	}

	if (level.mef_axis.spawnfrozenbodies)
	{
		waitthread global/libmef/ft.scr::create_frozen_bodies "axis"
	}
end


get_team_respawn_time local.team:
	if (local.team.nextrespawntime == NIL)
	{
		local.team.nextrespawntime = level.time + local.team.respawndelay
	}
end local.team.nextrespawntime


player_joined_server local.player:
	if (level.mef_freezemode)
	{
		waitthread global/libmef/ft.scr::player_joined_server local.player
	}
end


player_left_server local.auxdata:
	if (level.mef_freezemode)
	{
		waitthread global/libmef/ft.scr::player_left_server local.auxdata
	}
end


player_joined_team local.player:
	// check if the player joined a team
	if (local.player.dmteam == "allies" || local.player.dmteam == "axis")
	{
		if (level.mef_roundstate == "WAITING" || local.player.mef_team.state == "OPEN")
		{
			local.player.mef_gstate = "GSTATE_ALIVE"
		}
		
		if (local.player.mef_team.state == "DEAD" || (!local.player.mef_team.respawn && !level.mef_allowjoin))
		{
			local.player.mef_gstate = "GSTATE_DEAD"
		}
		
		if (local.player.mef_gstate == "GSTATE_DEAD")
		{
			local.player.mef_spectator = 1
		} else
		{
			local.player.mef_gstate = "GSTATE_ALIVE"
			
			if (local.player.mef_respawntime != NIL)
			{
				if (level.time < local.player.mef_respawntime)
				{
					local.player.mef_spectator = 1
				} else
				{
					local.player.mef_respawntime = NIL
				}
			}
		}

		thread wait_for_spawn local.player 15
	} else
	{
		local.player stopwatch 0
	}
end


wait_for_spawn local.player local.delay:
	local.team = local.player.dmteam

	local.endtime = level.time + local.delay
	while (local.player != NULL && local.player.dmteam == local.team && !local.player.mef_enteredgame)
	{
		if (level.time >= local.endtime)
		{
			local.player spectator
			break
		}
		waitframe
	}
end


player_left_team local.player:
	if (level.mef_freezemode)
	{
		waitthread global/libmef/ft.scr::player_left_team local.player.mef_auxdata
	}
end


player_entered_game local.player:
	if (level.mef_freezemode) 
	{
		waitthread global/libmef/ft.scr::player_entered_game local.player
	}
end


player_spawned local.player:
end


player_died local.player:
	if (!local.player.mef_team.respawn)
	{
		if (level.mef_roundstate == "ACTIVE")
		{
			local.player.mef_gstate = "GSTATE_DEAD"
			local.player.mef_spectator = 1
			if (local.player.mef_team.respawnmode == "ft")
			{
				waitthread global/libmef/ft.scr::freeze_player local.player
			}
		}
	} else if (local.player.mef_team.respawndelay > 0)
	{
		local.player.mef_respawntime = waitthread get_team_respawn_time local.player.mef_team
		local.player.mef_spectator = 1
	}
end


player_revived local.player:
	if (!local.player.mef_team.respawn)
	{
		if (local.player.mef_team.respawnmode == "ft")
		{
			if (local.player.mef_gstate == "GSTATE_DEAD" && local.player.ft_meltplayer != NIL)
			{
				waitthread global/libmef/ft.scr::melt_player local.player
			}
		}
	} else if (local.player.mef_respawntime != NIL && level.time >= local.player.mef_respawntime)
	{
		local.player.mef_spectator = 0
		local.player.mef_respawntime = NIL
	}
end


update_player_count:
	level.mef_allies.numplayers = 0
	level.mef_allies.totplayers = 0
	level.mef_axis.numplayers = 0
	level.mef_axis.totplayers = 0

	for (local.i = 0; local.i < level.mef_players.size; local.i++)
	{
		local.player = level.mef_players[local.i].player

		if (local.player.dmteam == "allies" || local.player.dmteam == "axis")
		{
			if (local.player.mef_gstate == "GSTATE_ALIVE")
			{
				local.player.mef_team.numplayers++
			}
			
			local.player.mef_team.totplayers++
		}
	}
end


get_winner_rb:
	if (level.mef_autonuke)
	{
		if (level.mef_allies.numplayers > level.mef_axis.numplayers)
		{
			local.winner = "allies"
		} else if (level.mef_axis.numplayers > level.mef_allies.numplayers)
		{
			local.winner = "axis"
		} else
		{
			local.winner = "draw"
		}
	} else
	{
		if (level.mef_allies.dead && level.mef_axis.dead)
		{
			local.winner = "draw"
		} else if (level.mef_axis.dead)
		{
			local.winner = "allies"
		} else if (level.mef_allies.dead)
		{
			local.winner = "axis"
		}
	}
end local.winner


teamnuke_thread local.secs:
	iprintlnbold_noloc (local.secs + " Seconds Remaining: Team with less players will be nuked.")

	local.ticker = spawn script_model
	local.ticker.origin = ( 0 0 0 )
	local.ticker model "items/pulse_explosive.tik"
	local.ticker notsolid
	local.ticker neverdraw

	local.ticker loopsound bombtick

	local.nuketime = level.time + local.secs
	local.finalticktime = local.nuketime - 10

	while (!level.mef_gameover && (level.time < local.nuketime))
	{
		if (!local.finalticking && level.time > local.finalticktime)
		{
			local.finalticking = 1
			local.ticker loopsound final_countdown
		}

		waitframe
	}

	local.ticker stoploopsound
end


nuke_team local.team:
	local.damage = 200
	local.radius = 52

	if (local.team == "allies")
	{
		iprintlnbold_noloc "Allied team nuked."
	} else if (local.team == "axis")
	{
		iprintlnbold_noloc "Axis team nuked."
	} else
	{
		iprintlnbold_noloc "Both teams nuked."
	}

	thread global/libmef/bomb.scr::jitter_large 0

	for (local.i = 0; local.i < level.mef_players.size; local.i++)
	{
		local.player = level.mef_players[local.i].player

		if (local.player != NULL && local.player.mef_pstate == "PSTATE_ALIVE" && (local.player.dmteam == local.team || local.team == "both"))
		{
			local.player playsound grenade_explode
			local.player takedamage
			radiusdamage local.player.origin local.damage local.radius
		}
	}
end


// team can be axis, allies, spectator, or all
respawn_players local.team:
	// reactivate the spawn blocks
	if (!level.mef_lockspawns)
	{
		if (local.team == "all")
		{
			thread global/libmef/spawn.scr::block_region "allies" 8
			thread global/libmef/spawn.scr::block_region "axis" 8
		} else if (local.team == "allies" || local.team == "axis")
		{
			thread global/libmef/spawn.scr::block_region local.team 8
		}
	}

	for (local.i = 0; local.i < level.mef_players.size; local.i++)
	{
		local.player = level.mef_players[local.i].player
		
		if (local.player.dmteam == local.team || local.team == "all")
		{
			waitthread global/libmef/ft.scr::remove_frozen_body local.player.mef_auxdata
			local.player.mef_gstate = "GSTATE_ALIVE"
			local.player.mef_spectator = 0
			local.player.ft_meltplayer = NIL
			local.player.ft_spawnfrozenbody = NIL
			local.player.mef_respawntime = NIL
		}
	}
end


check_team_state local.team:
	if (local.team.nextrespawnmode != NIL)
	{
		if (local.team.nextrespawnmode != local.team.respawnmode)
		{
			waitthread new_respawnmode local.team local.team.nextrespawnmode
			local.team.respawnmode = local.team.nextrespawnmode
		}
		local.team.nextrespawnmode = NIL
	}
		
	if (local.team.nextwaverespawn != NIL)
	{
		local.team.waverespawn = local.team.nextwaverespawn
		local.team.nextwaverespawn = NIL
	}

	if (!level.mef_gameover)
	{
		if (local.team.respawntime != NIL && level.time >= local.team.respawntime)
		{
			local.team.respawnplayers = 1
		}

		if (local.team.respawnplayers)
		{
			waitthread open_team local.team
			waitthread reset_allowjoin
			waitthread update_player_count
			local.team.respawnplayers = 0
			local.team.respawntime = NIL
		}
	}

	local.team.dead = 0
	local.team.wavekilled = 0

	if (!local.team.respawn && local.team.numplayers == 0 && !local.team.waverespawn)
	{
		local.team.dead = 1
	}

	switch (local.team.state)
	{
		case "OPEN":
		{
			if (local.team.numplayers > 0)
			{
				local.team.state = "ACTIVE"
			}
			break
		}
		
		case "ACTIVE":
		{
			if (!local.team.respawn && local.team.numplayers == 0)
			{
				if (local.team.waverespawn)
				{
					local.team.wavekilled = 1
				}

				local.team.state = "DEAD"
				if (local.team.respawnmode == "ft")
				{
					waitthread global/libmef/ft.scr::team_shatter local.team.name
				}
			}
			break
		}
	}

	if (local.team.nextrespawntime != NIL && level.time >= local.team.nextrespawntime)
	{
		local.team.nextrespawntime = NIL
	}
end


open_team local.team:
	local.team.state = "OPEN"

	if (local.team.respawnmode == "ft")
	{
		local.team.spawnfrozenbodies = 1
	}
	
	waitthread respawn_players local.team.name
end


init_respawnmode local.team local.respawnmode local.waverespawn:
	if (local.respawnmode == "full")
	{
		local.team.respawn = 1
	} else
	{
		local.team.respawn = 0
	}
	
	local.team.respawnmode = local.respawnmode
	local.team.waverespawn = local.waverespawn
end


new_respawnmode local.team local.nextrespawnmode:
	if (local.nextrespawnmode == "none")
	{
		if (local.team.respawnmode == "full")
		{
			local.team.respawn = 0
			waitthread respawn_dead_players local.team.name
		} else
		{
			waitthread global/libmef/ft.scr::team_shatter local.team.name
		}
	} else if (local.nextrespawnmode == "ft")
	{
		if (local.team.respawnmode == "full")
		{
			local.team.respawn = 0
			waitthread respawn_dead_players local.team.name
		} else
		{
			// none -> ft, no case
		}
	} else if (local.nextrespawnmode == "full")
	{
		local.team.respawn = 1
		local.team.respawnplayers = 1
	}
end


respawn_dead_players local.team:
	for (local.i = 0; local.i < level.mef_players.size; local.i++)
	{
		local.player = level.mef_players[local.i].player
		
		if (local.player.dmteam == local.team && local.player.mef_gstate == "GSTATE_ALIVE")
		{
			local.player.mef_spectator = 0
			local.player.mef_respawntime = NIL
			
			if (local.player.mef_pstate == "PSTATE_DEAD")
			{
				local.player.mef_forcerespawn = 1
			}
		}
	}
end


set_team_respawntime local.team local.secs:
	local.respawntime = level.time + local.secs
	if (local.team.respawntime == NIL || local.team.respawntime > local.respawntime)
	{
		local.team.respawntime = local.respawntime
	}
end


check_round_state:
	switch (level.mef_roundstate)
	{
		case "WAITING":
		{
			if (level.mef_allies.totplayers > 0 && level.mef_axis.totplayers > 0)
			{
				level.mef_roundstate = "ACTIVE"
				level.mef_roundclosetime = level.time + level.mef_allowjointime
			}
			break
		}
		
		case "ACTIVE":
		{
			if (level.mef_roundclosetime != NIL && level.time >= level.mef_roundclosetime)
			{
				level.mef_allowjoin = 0
				level.mef_roundclosetime = NIL
			}
			
			if (level.mef_allies.totplayers == 0 || level.mef_axis.totplayers == 0)
			{
				level.mef_roundstate = "WAITING"
				level.mef_allowjoin = 1
				waitthread respawn_players "all"
				waitthread update_player_count
			}
			break
		}
	}
end


reset_allowjoin:
	level.mef_allowjoin = 1
	level.mef_roundclosetime = level.time + level.mef_allowjointime
	waitthread respawn_players "spectator"
end


start_round:
	level.mef_roundstate = "WAITING"
	level.mef_allowjoin = 1
	waitthread open_team level.mef_allies
	waitthread open_team level.mef_axis
end


check_wave_killed:
	if (level.mef_allies.wavekilled && level.mef_axis.wavekilled)
	{
		level.mef_allies.respawnplayers = 1
		level.mef_axis.respawnplayers = 1
	} else if (level.mef_allies.wavekilled || level.mef_axis.wavekilled)
	{
		if (level.mef_allies.wavekilled)
		{
			local.team = level.mef_allies
		} else if (level.mef_axis.wavekilled)
		{
			local.team = level.mef_axis
		}
		
		if (local.team.otherteam.numplayers == 0)
		{
			local.team.respawnplayers = 1
		} else
		{
			thread team_waverespawn_thread local.team level.mef_waverespawndelay
		}

		local.team.otherteam.respawnplayers = 1
	}
end


team_waverespawn_thread local.team local.secs:
	iprintlnbold_noloc (local.team.desc + " team killed. " + local.team.otherteam.desc + " team has " + local.secs + " free seconds to advance!")

	local.endtime = level.time + local.secs
	
	while (!level.mef_gameover && local.team.waverespawn && local.team.state == "DEAD")
	{
		if (level.time > local.endtime)
		{
			local.team.respawnplayers = 1
			break
		}

		waitframe
	}
end


round_thread local.sdmins local.autonuke:
	local.anukesecs = 20
	local.sdsecs = local.sdmins * 60

	while (!level.mef_gameover)
	{
		local.dmroundlimit = level.dmroundlimit * 60
		
		if (level.mef_roundendtime != NIL && level.mef_roundendtime < local.dmroundlimit)
		{
			local.endtime = level.mef_roundendtime
		} else
		{
			local.endtime = local.dmroundlimit
		}

		if (level.mef_elapsedtime >= (local.endtime - 1))
		{
			level.mef_timeexpired = 1
			if (local.autonuke)
			{
				level.mef_autonuke = 1
			}
			end
		} else if (local.sdmins > 0 && !level.mef_suddendeath && (level.mef_elapsedtime >= (local.endtime - local.sdsecs)))
		{
			level.mef_suddendeath = 1
			iprintlnbold_noloc (local.sdmins + " Minute Sudden Death: Respawning Disabled.")
			waitthread disable_respawn
		} else if (local.sdmins > 0 && !level.mef_suddendeath && !local.announcesd && (level.mef_elapsedtime >= (local.endtime - local.sdsecs - 20)))
		{
			local.announcesd = 1
			iprintlnbold_noloc ("Warning: Respawning ends in 20 seconds.")
		} else if (local.autonuke && !local.announcenuke && (level.mef_elapsedtime >= (local.endtime - local.anukesecs)))
		{
			local.announcenuke = 1
			thread teamnuke_thread local.anukesecs
		}

		wait 0.5
	}
end


disable_respawn:
	level.mef_respawnmode = "none"
	level.mef_allies.nextrespawnmode = "none"
	level.mef_axis.nextrespawnmode = "none"
	level.mef_allies.nextwaverespawn = 0
	level.mef_axis.nextwaverespawn = 0
	level.mef_allowjoin = 0
	level.mef_roundclosetime = NIL
end
